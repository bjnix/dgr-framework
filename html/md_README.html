<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>My Project: DGR Framework (DISTRIBUTED GRAPHICS RENDERER) (pronounced &quot;Dogger&quot;)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">DGR Framework (DISTRIBUTED GRAPHICS RENDERER) (pronounced "Dogger") </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Written by Brent Nix (bjnix at mtu dot edu) and James Walker (jwwalker at mtu dot edu), with some modifications by Scott A. Kuhl (kuhl at mtu dot edu)</p>
<h2>OVERVIEW </h2>
<p>Originaly meant for distributed graphics rendering, DGR is a small lightweight general use framework that allows for syncing data between servers with minimal code intrusion. It takes primitive data types by default, but can be configured to accept any data type, structure, or object.</p>
<h2>HOW IT WORKS </h2>
<p>Here is an overview of how DGR works:</p>
<p>The MASTER program forwards state data via UDP packets to the relay program running on the head node of the cluster.</p>
<p>The RELAY, running on the head node of the cluster, listens for packets from the master program and automatically forwards them to an IP address (which could be a broadcast address, and is by default).</p>
<p>The SLAVES listen for packets on the appropriate port. Upon receipt, they immediately decode the packets and update their state with the data.</p>
<p>The basic premise here is a master - slave relationship. The specifics of how this relationship is implemented is completely up to you, but examples are provided for some more common constructs. Here are the examples that we have implemented:</p>
<p>1) Having a master node that talks to a relay on a cluster head </p><pre class="fragment">                                                           {slave}
                                                           {slave}
                                      {Master}---&gt;{relay}--{slave}
                                                           {slave}
                                                           {slave}
</pre><p>2) Running directly off of the cluster head (the relay functionality is moved into the master code) </p><pre class="fragment">                                                           {slave}
                                                           {slave}
                                         {master/relay}----{slave}
                                                           {slave}
                                                           {slave}
</pre><p>and finally, a purely local environment allows us to recreate the above situations for local testing purposes. </p><pre class="fragment">                                                master
                                      {relay,slave,slave,slave,...}

                                                  or

                                             master/relay
                                      {slave,slave,slave,slave,...}
</pre><p>Some sample "run-scripts" have been included to help you get started:</p>
<p>Scripts specifically for Michigan Tech's IVS Display Wall:</p>
<ul>
<li>DGRStartIVS.sh</li>
<li>DGRStartIVS-startslaves.sh note: DGRStartIVS.sh calls DGRStartIVS-startslaves.sh</li>
</ul>
<p>For testing on one machine:</p>
<ul>
<li>DGRStartLocal.sh note: this may need some serious editing for your purposes</li>
</ul>
<h2>TO COMPILE THE PACKAGES </h2>
<ul>
<li>Compile the package by typing "make".</li>
<li>testing_around.cpp has been provided as an example</li>
<li>This code should work with linux and OSX.</li>
<li>it has not been tested on windows and will likely not work without modification</li>
</ul>
<h2>DEVELOPING YOUR OWN DISTRIBUTED RENDERING PROGRAMS </h2>
<ul>
<li>The testing_around.cpp demo illustrates how to accomplish distributed rendering on a graphics cluster using only UDP packets, without relying on libraries such as Chromium.</li>
<li>DGR is independent of the windows composter or graphics libraries so it allows you to sync renderings between different windows managers and operating systems, having separate slave implementations for each.</li>
<li>Because DGR is a memory synchronizer, you can extend this concept for any distributed computation purposes, not just graphics.</li>
<li>You must include "DGR_framework" in the files that you wish to use DGR in as well as compile your code with "DGR_framework.cpp"</li>
<li><p class="startli">Because the source code for the master and slaves may be almost identical, you can have both binaries compiled out of the same source file. The code below demonstrates how to use preprocessor directives to separate out parts that are different between the master and the slave. I don't think that I have to mention that some care should be taken when choosing how to cut the code up. <b>note:</b> <em>use -DDGR_MASTER=1 with gcc for the MASTER and omit it for the SLAVE.</em></li>  </p><pre class="fragment">
        #ifdef DGR_MASTER 
        //C++ code for the master program 
        #else 
        //C++ code for the slave program 
        #endif

        #ifdef DGR_MASTER 
        //C++ code for the master program 
        #endif

        #ifndef DGR_MASTER 
        //C++ code for the SLAVE program. #if*n*def means "if not defined" 
        #endif
</pre>
<li><p class="startli">The way that DGR must be instantiated is different for the MASTER and SLAVE nodes (I.E. inside the preprocessor <code>#ifdef</code> statements: <b>For the MASTER:</b> </p><pre class="fragment">
<a class="el" href="classDGR__framework.html">DGR_framework</a> myDGR = new <a class="el" href="classDGR__framework.html#a3c397bacb6d9f5415c1ccd91d68da842">DGR_framework(char * r_IP)</a>; </pre>
<p class="startli">where <code>r_IP</code> is the relay address in a <b>character array</b></p>
<p class="startli"><b>For the SLAVE:</b> </p>
  <pre class="fragment"><a class="el" href="classDGR__framework.html">DGR_framework</a> myDGR = new <a class="el" href="classDGR__framework.html#a30d61a56e39d2e240da947a0fa1412b4">DGR_framework()</a>;</pre>
<p class="startli">which will set the slave listening port to RELAY_LISTEN_PORT defined in <a class="el" href="DGR__framework_8h_source.html">DGR_framework.h</a></p>
<p class="startli"><b>or</b></p>
<p class="startli">If you would like to specify the listening port, do it like this: </p>
<pre class="fragment"> <a class="el" href="classDGR__framework.html">DGR_framework</a> myDGR = new <a class="el" href="classDGR__framework.html#ae7789d2c0b2e6a3f5b713ad5b87dda49">DGR_framework(int slave_listen_port)</a>;</pre>
</li>
<li><p class="startli">Variable registration <b>must</b> be in both MASTER and SLAVE code. Future versions will have more robust error checking, but failing to have variables added on both MASTER and SLAVE nodes may cause errors. (I.E. not inside of any of the preprocessor "ifdef" statements):</p>
<p class="startli"><pre class="fragment"> myDGR-&gt;<a class="el" href="classDGR__framework.html#aadf62190c414a2b7799d630d807cd075">addNode&lt;T&gt;(std::string name, &#42;T data)</a> </pre> <b>note:</b> _the above method will only work with POD (Plain Old Data) types _</p>
<p class="startli">In order to sync other types, you have to specialize templates. The following code is an example from fitashape, a game made to be run on the Michigan Tech IVS display wall.</p>
<p class="startli">First, <em>serialize</em> the data, copying each into the necessary array: </p>
<pre class="fragment"> 
  template&lt;&gt; 
  char * <a class="el" href="classMapNode.html#aec1d6c32ce5cf507bdf8459cdd9a00b8">MapNode&lt;Player&gt;::getDataString</a>(char data_array){ 
    //pulling the data out of the object 
    std::vector&lt;vector3df&gt; dataPos = data-&gt;getPositions(); 
    //putting that data into an array 
    float float_array[12]; 
    dataPos[0].getAs3Values( &amp;( float_array[0] ) ); 
    dataPos[1].getAs3Values( &amp;( float_array[3] ) ); 
    dataPos[2].getAs3Values( &amp;( float_array[6] ) ); 
    dataPos[3].getAs3Values( &amp;( float_array[9] ) ); 
    //copying that data into the given buffer memcpy(data_array, float_array, dataLength); 
  } </pre>

<p class="startli">Next, reverse the process and <em>parse</em> the data back into the object from the array that you just made:</p>
  <pre class="fragment">
  template&lt;&gt; 
  void <a class="el" href="classMapNode.html#a78cc24f37a1d1b4bda5075284ff53f92">MapNode&lt;Player&gt;::setData(char * data_array)</a>{ 
    float float_array[24]; 
    //copy raw data into "datatyped" array 
    memcpy(float_array, data_array, dataLength); 
    std::vector&lt;vector3df&gt; dataPos; 
    //object specific parsing 
    dataPos.push_back(vector3df(float_array[0],float_array[1],float_array[2])); 
    dataPos.push_back(vector3df(float_array[3],float_array[4],float_array[5])); 
    dataPos.push_back(vector3df(float_array[6],float_array[7],float_array[8])); 
    dataPos.push_back(vector3df(float_array[9],float_array[10],float_array[11])); 
    data-&gt;setNodePositions(dataPos); 
  } </pre>
</li>
<li>To guarantee good performance, YOU MAY WANT TO CAP THE RATE AT WHICH THE MASTER SENDS UDP PACKETS TO ABOUT 60 PER SECOND, but feel free to experiment.</li>
<li>Please note that for more complex programs, master-defined state machines are necessary. Without them you will veritably run into race conditions. <b>Software using DGR must be made in a concurrent programming paradigm.</b></li>
<li>You will need a simple relay program. DGR_relay.cpp is provided as an example. The relay's ONLY responsibility is to RECEIVE packets from the MASTER and immediately SEND those packets to the SLAVES (for greatest efficiency, just broadcast them). DGR_relay accepts the sendto IP address and can also accept SLAVE listening ports</li>
<li>The SLAVES receive state data generated by the MASTER and use that to update their displays. When initialized, the slave must be given VIEWPORT INFORMATION telling it WHICH PART of the display it is responsible for (e.g., the upper-left, the middle-right, etc.). This is what enables the slaves to correctly divide their views using the glFrustum function (the D3D equivalent is D3DXMatrixPerspectiveOffCenterLH). See the demo for an example.</li>
<li>The relay and slaves are set up to automatically terminate themselves if they haven't received any packets in a while, so you should only need to worry about closing the master program. However, killSlaves.sh has been provided as a catchall Michigan Tech's IVS wall if anything should go wrong.</li>
</ul>
<h2>SUPPORT </h2>
<p>If you have questions, comments, or need assistance with this demo or using the demo to distribute rendering in your own programs, please contact</p>
<ul>
<li>bjnix at mtu dot edu &nbsp;&nbsp;&lt;&lt; currently maintains this repo (<em>direct questions here first</em>) </li>
<p class="startli"><em>and/or</em></p>
<li>jwwalker at mtu dot edu</li>
<p class="startli"><em>and/or</em></p>
<li>kuhl at mtu dot edu </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 27 2014 20:03:02 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
